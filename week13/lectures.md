# week 13 lectures notes

## lecture 31 快速排序 I、II

核心思路——分割（Partition），随机选出一个元素，给它进行排序，使得排序后的数组中，它左侧的所有元素都小于等于它，其右侧的元素都大于等于它。数组就自然被分割成有大小的左右两堆，然后递归地对左右两堆继续进行分割操作，直到所有元素都排序。

- 随机选出的元素叫 pivot

- 快速排序是一种基于二分搜索树的排序（BST Sort），基于 pivot 选得足够随机的情况下
  - 在进行分割时，比较的次数和为这个数组构建一个 BST 的比较次数是一样的

- 运行时，取决于 pivot 怎么选以及数组的打乱情况
  - best case：O(N logN)，在数组本身是乱序，且 pivot 选得足够随机情况下
  - worst case：O(N^2)，在数组已排序或 pivot 选得是最大/最小值的情况下

### 如何避免快速排序的最差情况

基本上能从三个方向优化：

- pivot 选择
- 分割算法
- 避免 worst case 的措施

假设现在有一种快速排序，它：
  - pivot 选择：只选第一个元素
  - 分割算法：遍历 3 次原始数组，以 pivot 为界限复制到新数组
  - 每次开始前都打乱（Shuffle）数组，以避免 worst case
  - 我们叫这个快速排序为，Quicksort L3S 号

**分割算法上的优化**

一种比 MergeSort（以及 Quicksort L3S）更快的快速排序实现：**Quicksort LTHS**

Quicksort LTHS 的优化主要体现在分割算法的提升上，算法由 Tony Hoare 发明，先说一种简单的分割算法实现：
  - 创建一个新数组
  - 遍历原数组，遇到比 pivot 大的，从末尾开始插入新数组；遇到小的，从起始位置插入新数组，最后在新数组空余的地方填入 pivot
  - 时间复杂度 O(N)，空间复杂度 O(N)

Hoare Partitioning 算法为：
  - 使用两个指针 L、G，除了 pivot 以外，L 指向最左端，G 指向最右端；
  - 遍历开始，两个指针对向行进，但做不同的判断：
    - L 指针向右遍历时，放过比 pivot 小的元素，但遇到比 pivot 相等或更大的元素，在该位置停下；
    - G 指针向左遍历时，放过比 pivot 大的元素，但遇到比 pivot 相等或更小的元素，在该位置停下；
    - 两个指针都停下时，交换指针所在的元素的值，然后各自前进一格，继续遍历
    - 两个指针一交叉，就结束遍历。交叉前，L 在左 G 在右；交叉后，L 在右 G 在左。
  - 将 pivot 位置的元素与 **G 位置的元素互换**

**pivot 选择上的优化——选数组中的中间值**：先找到数组的中间元素，作为 pivot，基于它展开分割，时间复杂度是 log(N logN)

- 分割不仅仅是快速排序的一种过程，也是一种通用的解决问题的思路，比如，可以用分隔来找数组的中间值，这个操作叫快速选择（Quick Select）：
  - 对一个 pivot 进行分割，分割后，它左边的元素更多，就继续对右边的子数组进行分割
  - 直到得到一个 pivot 位于数组中间
  - 平均运行时：Θ(N)

